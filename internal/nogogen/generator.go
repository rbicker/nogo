package nogogen

import (
	"bytes"
	"encoding/gob"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/rbicker/nogo"
)

// Define vars for build template
var conv = map[string]interface{}{"conv": fmtByteSlice}
var tmpl = template.Must(template.New("").Funcs(conv).Parse(`package main

import "github.com/rbicker/nogo"

// Code generated by github.com/rbicker/nogo; DO NOT EDIT.

func init() {
    {{- range $name, $file := . }}
        nogo.Add("{{ $name }}", []byte{ {{ conv $file }} })
    {{- end }}
}`),
)

// format byte slice
func fmtByteSlice(s []byte) string {
	builder := strings.Builder{}

	for _, v := range s {
		builder.WriteString(fmt.Sprintf("%d,", int(v)))
	}

	return builder.String()
}

// Run execudes the code generation.
func Run() {
	log.Println("starting nogo generator")
	// find module directory directory
	cmd := exec.Command("go", "env", "GOMOD")
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("unable to run 'go env GOMOD': %v", err)
	}
	if len(out) == 0 {
		log.Fatalf("empty result when running 'go env GOMOD - are you in a go module directory?")
	}
	modPath := filepath.Dir(string(out))

	// determine directories to include
	paths := []string{"/assets"}
	v, k := os.LookupEnv("NOGO_DIRS")
	if k {
		paths = strings.Split(v, " ")
	}
	log.Printf("using the following paths: %v\n", paths)

	// determine resulting go file
	targetFile := "/nogo.go"
	v, k = os.LookupEnv("NOGO_FILE")
	if k {
		targetFile = v
	}
	targetFile = modPath + targetFile
	log.Printf("using the following target file: %v\n", targetFile)

	// map for nogo files
	files := make(map[string][]byte)

	// encoder
	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)

	// loop through paths
	for _, pth := range paths {
		pth = modPath + pth
		if _, err := os.Stat(pth); os.IsNotExist(err) {
			log.Fatalf("path does not exist: %v", pth)
		}
		err = filepath.Walk(pth, func(p string, info os.FileInfo, err error) error {
			relativePath := filepath.ToSlash(strings.TrimPrefix(p, modPath))
			log.Printf("adding file: %v\n", relativePath)
			f, e := nogo.LoadFile(p)
			if e != nil {
				return fmt.Errorf("error creating nogo file: %v", e)
			}
			if e = enc.Encode(f); e != nil {
				return fmt.Errorf("error encoding nogo file: %v", e)
			}
			// get slice of bytes from buffr
			b := make([]byte, len(buf.Bytes()))
			copy(b, buf.Bytes())
			buf.Reset()

			// add file to map
			files[relativePath] = b

			return nil
		})
		if err != nil {
			log.Fatalf("error walking through path: %v", err)
		}
	}

	// create blob file
	f, err := os.Create(targetFile)
	if err != nil {
		log.Fatalf("Error creating file: %v", err)
	}
	defer f.Close()

	// create buffer
	builder := &bytes.Buffer{}

	// execute template
	if err = tmpl.Execute(builder, files); err != nil {
		log.Fatalf("Error executing template: %v", err)
	}

	// formatting generated code
	data, err := format.Source(builder.Bytes())
	if err != nil {
		log.Fatalf("Error formatting generated code: %v", err)
	}

	// writing blob file
	if err = ioutil.WriteFile(targetFile, data, os.ModePerm); err != nil {
		log.Fatalf("Error writing file: %v", err)
	}
	log.Printf("sucessfully wrote: %v", targetFile)
	log.Println("nogo generator sucessfully finished")
}
